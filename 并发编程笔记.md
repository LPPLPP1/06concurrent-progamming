# 							并发编程艺术

## 一并发编程基础

### 1. 线程和进程

1. 进程：它是内存中的一段独立的空间，可以负责当前应用程序的运行。当前这个进程负责调度当前程序中的所有运行细节。
2. 线程：它是位于进程中，负责当前进程中的某个具备独立运行资格的空间。

---



### 2. 创建线程的3种方式

#### 2.1 继承Thread类

> Thread 类本质上是实现了 Runnable 接口的一个实例，代表一个线程的实例。

```java
public class Demo1 {
	public static void main(String[] args) {
		MyThread mt = new MyThread();//4,创建自定义类的对象
		mt.start();                //5,开启线程
	}
}

class MyThread extends Thread {   //1,定义类继承Thread
	public void run() {        		//2,重写run方法
		System.out.println("run");//3,将要执行的代码,写在run方法中
	}
}
```

```java
public void method1(){
    //匿名内部类
    new Thread() {           			
        public void run() {      		
            System.out.println("run thread...");
        }
    }.start();
}
```



#### 2.2 实现Runable接口

```java
public class Demo2 {
	public static void main(String[] args) {
		MyRunnable mr = new MyRunnable();   //4,创建自定义类对象
		Thread t = new Thread(mr);        //5,将其当作参数传递给Thread的构造函数
		t.start();                            //6,开启线程
	}
}

class MyRunnable implements Runnable {  //1,自定义类实现Runnable接口
	public void run() {              //2,重写run方法
		System.out.println("run");//3,将要执行的代码,写在run方法中
	}
}

```

```java
public void method1(){
    //匿名内部类+lamba 简写方式
    new Thread(() -> {
        System.out.println("run");
    }).start();
}
```

#### 2.3 实现Callable接口

`Callable`是jdk1.5新加的,可以获取返回值,可以抛异常

```java
public class Demo3 {

	public static void main(String[] args) throws ExecutionException, InterruptedException {
		ExecutorService executorService= Executors.newFixedThreadPool(1);
		Future<String> future=executorService.submit(new MyCallable());
		String s = future.get(); //通过future来获取返回值,进程没有计算结束,get()会一直阻塞等待
		System.out.println(s);
		executorService.shutdown();//会在所有任务完成的情况下,才会关闭线程池
	}
}

class MyCallable implements Callable { //1,自定义类实现Callable接口
	@Override
	public String call() {
		int a = 1;
		int b = 2;
		return "执行结果:" + (a + b);
	}
}
```

---



### 3. 线程的状态

#### 3.1 线程的6种状态

> 线程一共有 6 种状态（`NEW`、`RUNNABLE`、`BLOCKED`、`WAITING`、`TIME_WAITING`、`TERMINATED`）
>
> 可以通过thread.getState()获取到线程的当前状态

| 状态名称     | 说明                                                         |
| ------------ | ------------------------------------------------------------ |
| NEW          | 初始状态，线程被构建，但是还没有调用 start 方法              |
| RUNNABLED    | JAVA 线程把操作系统中的就绪和运行两种状态统一称为“运行中”    |
| BLOCKED      | 阻塞状态,表示线程==阻塞于锁==                                |
| WAITING      | 等待状态,表示线程进入等待状态,需要其他线程做出一些特定动作(通知或中断),才会退出等待状态 |
| TIME_WAITING | 超时等待状态，该状态不同于WAITING,他是可以在指定时间自行返回的 |
| TERMINATED   | 终止状态，表示当前线程执行完毕                               |

> BLOCKED：阻塞状态，表示线程进入等待状态,也就是线程因为某种原因放弃了 CPU 使用权，阻塞也分为几种情况
>
> 1. 等待阻塞：运行的线程执行 wait 方法(释放锁,然后在该锁上等待)，jvm 会把当前线程放入到等待队列
> 2. 同步阻塞：运行的线程在获取对象的同步锁时，若该同步锁被其他线程锁占用了，那么 jvm 会把当前的线程放入到锁池中,进入到同步阻塞状态中
> 3. 其他阻塞：运行的线程执行 t.join 方法，或者发出了 I/O请求时，JVM 会把当前线程设置为阻塞状态，当 join 线程终止、io 处理完毕则线程恢复

![1534256828364](并发编程笔记.assets/1534256828364.png)

#### 3.2 查看线程状态的方法

1. 打开终端或者命令提示符，键入“jps”，（JDK1.5 提供的一个显示当前所有 java进程 pid 的命令）
2.  根据上一步骤获得的 pid，继续输入 jstack pid（jstack 是 java 虚拟机自带的一种堆栈跟踪工具。jstack 用于打印出给定的 java 进程 ID 或 core file 或远程调试服务的 Java 堆栈信息）

---



### 4. Thread常用的方法

#### 4.1 `sleep`()和`wait()`

| sleep()                                                    | wait()                                                       |
| :--------------------------------------------------------- | :----------------------------------------------------------- |
| 属于Thread的方法                                           | 属于Object的方法                                             |
| sleep(long millis) <br />sleep(long millis,int nanos)      | wait() <br />wait(long millis) <br />wait(long millis,int nanos) |
| <b可以在任何情况下运用<br /> ==该线程被sleep后不会释放锁== | 只能用在同步代码块或同步方法中<br /> ==当该线程被wait时,会释放锁,然后再该锁上等待== |

---



#### 4.2 `setDaemon()`-- 守护线程

##### 4.2.1 原理

> 1. 设置一个线程为守护线程, 该线程不会单独执行, 当其他非守护线程都执行结束后,自动退出
> 2. Main主线程结束了（==Main线程是Non-daemon线程==）,如果此时正在运行的其他threads是daemon threads,JVM会使得这个threads停止,JVM也停下.如果此时正在运行的其他threads有Non-daemon threads,那么必须等所有的Non daemon线程结束了，JVM才会停下来.
> 3. 总之,必须等所有的Non-daemon线程都运行结束了，只剩下daemon的时候，JVM才会停下来



##### 4.2.2 示例

设为守护，则程序在1s后退出。

不守护，则程序死循环输出。

```java
public static void main(String[] args) throws InterruptedException {
    Thread thread = new Thread(() -> {
        int i = 1;
        for (; ; ) {
            System.out.println("hello,world+" + i++);
        }
    });
    // thread.setDaemon(true);   //设置为守护进程
    thread.start();
    Thread.sleep(1000);
}
```

---



#### 4.3 `join()`--加入线程

> 调用 thread.join() 的程进入 TIMED_WAITING 状态，等待 join() 所属线程运行结束后再继续运行。 



##### 4.3.1 **示例**:演示多个线程顺序执行

```java
public class JoinDemo {
    public static void main(String[] args) throws InterruptedException {
        Thread t1 = new Thread(() -> {
            System.out.println("t1");
        });
        Thread t2 = new Thread(() -> {
            System.out.println("t2");
        });
        Thread t3 = new Thread(() -> {
            System.out.println("t3");
        });
        t1.start();
        t1.join();//main线程调用的该方法,main线程会进入wait方法,当t1运行结束时,才会被唤醒(notifyAll)
        t2.start();
        t2.join();
        t3.start();
        t3.join();
    }
}
```

```pro
//输出的结果,就会是线程顺序运行之后的结果
t1
t2
t3
```



##### 4.3.2 **源码解析**

```java
public final void join() throws InterruptedException {
    join(0);
}
//注意方法是synchronized修饰的,wait()只能用在同步代码中,
public final synchronized void join(long millis) throws InterruptedException {
    long base = System.currentTimeMillis();
    long now = 0;

    if (millis < 0) {
        throw new IllegalArgumentException("timeout value is negative");
    }

    if (millis == 0) {
        while (isAlive()) {
            wait(0);
        }
    } else {
        while (isAlive()) {
            long delay = millis - now;
            if (delay <= 0) {
                break;
            }
            wait(delay);
            now = System.currentTimeMillis() - base;
        }
    }
}
```

核心代码:

```java
while (isAlive()) {
　　wait(0); //如果 timeout 为零，则不考虑实际时间，在获得通知前该线程将一直等待。
}
```

isAlive是 join方法的本意和目标。即使中间被唤醒（虚拟唤醒,他仍然会再次调用wait(0)来等待下一次通知。

最终，线程死的时候会调用自己的notifyAll方法，join会执行结束。 

> 当main线程调用t1.join时候，main线程会获得线程对象t1的锁（wait 意味着拿到该对象的锁),调用该对象的wait(等待时间)，直到该对象唤醒main线程 ,然后main线程会被阻塞,知道t1线程运行完,会调用自己的notifyall方法,激活main线程.

---



#### 4.4 `yield()`--礼让线程

当一个线程抢到执行权后，执行到yield()方法后，就会放弃执行权，其他线程就可以拿到执行权 了

####  4.5 ~~`stop`~~--~~弃用的停止线程方法~~

>  thread.stop() 等同于 kill -9 pid ,相当于强制暂定线程,如果线程正在运行任务,会导致一些意外的情况,所以弃用了,我们使用的时候要慎重
>
> 其他因为相同原因弃用的方法: `suspend`、`resume` 

#### 4.6 `interrupt()`-设置线程中断标记

1. 若线程被`Object.wait`, `Thread.join`和`Thread.sleep`三种方法之一阻塞 ，调用了它的interrupt()方法，那么它的“中断状态”会被清除并且会收到一个`InterruptedException`异常

   例如，线程通过sleep()进入阻塞状态，此时通过interrupt()中断该线程；调用interrupt()会立即将线程的中断标记设为“true”，但是由于线程处于阻塞状态，所以该“中断标记”会立即被清除为“false”，同时，会产生一个`InterruptedException`的异常。

   ```java
   public static void main(String[] args) throws InterruptedException {
       Thread thread = new Thread(() -> {
           try {
               Thread.sleep(3000);
           } catch (InterruptedException e) {
               //由于产生InterruptedException异常，线程终止！
               log.info("exception:{}",e.getLocalizedMessage());
           }
       });
       thread.start();
       log.info("1,{}",String.valueOf(thread.isInterrupted()));//false
       thread.interrupt();
       log.info("2,{}",String.valueOf(thread.isInterrupted()));//true
       TimeUnit.SECONDS.sleep(1);
       log.info("3,{}",String.valueOf(thread.isInterrupted()));//false
   }
   ```

   ```properties
   1,false
   2,true
   exception:sleep interrupted
   3,false
   ```

2. 如果线程正常运行,当调用interrupt()方法时,只是会把线程的中断标记设置为"true",不会有其他效果

   例如,我们可以通过获取线程的中断标记值,来中断线程

   ```java
   public static void method1() throws InterruptedException {
       Thread thread = new Thread(() -> {
           //thread.isInterrupted():获取线程的中断标记的值
           while (!Thread.currentThread().isInterrupted()) {
               i++;
           }
           log.info("Num:" + i);
       });
       thread.start();
       TimeUnit.SECONDS.sleep(1);
       thread.interrupt();
   }
   ```

3. interrupt相关的方法

   * new Thread().isInterrupted():获取线程的中断标记值

     ```java
     public boolean isInterrupted() {
       return isInterrupted(false);
     }
     //ClearInterrupted为true时,会复位中断标志
     private native boolean isInterrupted(boolean ClearInterrupted);
     ```

   * Thread.interrupted(): 复位线程的中断标记为false

     ```java
     public static boolean interrupted() {
         return currentThread().isInterrupted(true);//参数为ture
     }
     private native boolean isInterrupted(boolean ClearInterrupted);
     
     ```


#### 4.7 如何优雅的停止线程

##### 4.7.1 通过interrupt()方法实现

```java
private static void method2() throws InterruptedException {
    Thread thread = new Thread(() -> {
        try {
            while (!Thread.currentThread().isInterrupted()) {//判断线程中断标记
                Thread.sleep(100); // 休眠100ms
                //do something
            }
        } catch (InterruptedException e) {//用户捕获阻塞线程因中断抛出的异常
            e.printStackTrace();
        }
    });
    thread.start();
    System.out.println("begin start thread");
    Thread.sleep(1000);
    thread.interrupt();
}
```



##### 4.7.2 通过一个标志位实现

```java
//volidate能够保证变量被修改时,其他线程立马刷新新的stop值
private volatile static boolean stop = false;

public static void main(String[] args) throws InterruptedException {
    Thread thread = new Thread(() -> {
        while (!stop) { //通过标志位,来判断是否终止线程
           //do someting
        }
    });
    thread.start();
    System.out.println("begin start thread");
    Thread.sleep(1000);
    stop = true; //设置标志为true来中断线程
}
```



#### 4.8 `setPriority()`-线程的优先级设置

>  thread.setPriority() 设置线程的优先级,范围[1,10],数字越大,线程优先级越高
>
> 需要注意: 有些操作系统可能忽略线程优先级的设定.

### 5. 线程的安全问题

#### 5.1 产生安全问题的原因

> ###### ==多个线程操作共享数据,就会导致出现安全问题,使用时,用这个标准判断==

```java
public class TicketDemo {
    public static void main(String[] args) {
        Ticket ticket = new Ticket();
        new Thread(ticket).start();
        new Thread(ticket).start();
        new Thread(ticket).start();
    }

}

@Slf4j
class Ticket implements Runnable {
    private int ticket = 100;

    public void run() {
        for (; ; ) {
            if (ticket > 0) {
                log.info("出售第{}张票", ticket--);//1
            }
        }
    }
}
```

当线程0走到if中时(1位置),刚判断完后正准备做打印ticket--动作时,cpu被线程1抢走了

这时线程1还是从100张票开始判断,然后打印出售第100张票,ticket--,变成99张票	

此时切换到线程0,由于已经经过了判断,这时还是打印出售第100张票.

所以就会出现同时出售100张票,就出现了安全隐患

#### 5.2 解决方式1:`synchronized`

##### 5.2.1 同步代码块

```java
public class TicketDemo {
	public static void main(String[] args) {
		Ticket ticket = new Ticket();
		new Thread(ticket).start();
		new Thread(ticket).start();
		new Thread(ticket).start();
	}
}
@Slf4j
class Ticket implements Runnable {
	private int ticket = 100;

	public void run() {
		for (; ; ) {
			synchronized (TicketDemo.class){ //多个方法访问,需要使用唯一的锁
				if (ticket > 0) {
					log.info("出售第{}张票", ticket--);
				}
			}
		}
	}
}
```

##### 5.2.2  同步方法

==同步方法也有锁,是隐式的==

==非静态同步方法的锁是:this==

==静态的同步方法的锁是:本类的字节码对象==

```java
public class TicketDemo {
	public static void main(String[] args) {
		Ticket ticket = new Ticket();
		new Thread(ticket).start();
		new Thread(ticket).start();
		new Thread(ticket).start();
	}

}
@Slf4j
class Ticket implements Runnable {
	private int ticket = 100;

	public void run() {
		doTicket();
	}
	public synchronized void doTicket(){ //同步方法
		for (; ; ) {
			synchronized (TicketDemo.class){
				if (ticket > 0) {
					log.info("出售第{}张票", ticket--);
				}
			}
		}
	}
}

```

#### 5.3 解决方式2 :`Lock锁`

Lock接口中有2个方法

* void lock() 获取锁

* void unLock() 释放锁

由于是接口,可以使用它的实现类ReentrantLock

```java
public class TicketDemo {
	public static void main(String[] args) {
		Ticket ticket = new Ticket();
		new Thread(ticket).start();
		new Thread(ticket).start();
		new Thread(ticket).start();
	}
}

@Slf4j
class Ticket implements Runnable {
	private int ticket = 100;
	private Lock lock = new ReentrantLock();//1.创建锁对象
	public void run() {
		for (; ; ) {
			lock.lock(); //2.上锁
			try {
				if (ticket > 0) {
					log.info("出售第{}张票", ticket--);
				}
			} catch (Exception e) {
				e.printStackTrace();
			} finally {
				/*
				  3.写在finally中,会一定释放锁
				  当出现异常时,其他线程可以继续运行
				 */
				lock.unlock();
			}
		}
	}

}
```

具体的锁使用,可以查看后续的锁章节

### 6. 线程通信-`wait()/notify()`

#### 6.1 什么时候需要通信

	多个线程并发执行时, 在默认情况下CPU是随机切换线程的
	
	如果我们希望他们有规律的执行, 就可以使用通信, 例如每个线程执行一次打印

#### 6.2 怎么通信

* 如果希望线程等待, 就调用wait()
  * 当前线程必须拥有此对象的monitor（即锁),才能调用某个对象的wait()方法能让==当前线程阻塞,同时会立即释放锁==
  * 阻塞线程必须有其他线程通过在同一把锁上的notify()/notifyAll()唤醒重新竞争获得锁

* 如果希望唤醒等待的线程, 就调用notify()/notifyAll();

  * notify()/notifyAll()是解除线程在该锁上的waiting状态.	

* ==这两个方法必须在同步代码中执行, 并且使用同步锁对象来调用==


#### 6.3 案例:让两个线程交替执行任务	

> 2个线程,一个生产者producer,一个消费者consumer
>
> producer生产一个apple,然后consumer消费一个apple,周期运行,没有生产不能消费

```java
//资源类:苹果
public class Apple {
    public int index;
    public boolean flag;
    public void product() {
        try {
            Thread.sleep(1000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.printf("生产第%d个苹果\n",++index);
    }

    public void take(){
        try {
            Thread.sleep(1000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.printf("消费第%d个苹果\n",index);
    }
}

```

```java
//生产者
public class Producer implements Runnable {

    private Apple apple;

    public Producer(Apple apple) {
        this.apple = apple;
    }

    @Override
    public void run() {
        while (true) {
            synchronized (apple) {
                if (apple.flag) {
                    try {//flag为true,说明苹果还没有消费,就阻塞producer,并释放锁
                        apple.wait();
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }
                //走到这,说明,flag=false,苹果被消费了
                apple.product();//生产一个苹果
                apple.flag = true;//设置为true,让消费者可以消费了
                apple.notify();//唤醒在resource锁上等待的对象
            }
        }
    }
}

```

```java
//消费者
public class Consumer implements Runnable {
    private Apple apple;

    public Consumer(Apple apple) {
        this.apple = apple;
    }

    @Override
    public void run() {
        while (true){
            synchronized (apple){
                if (!apple.flag) {
                    try {//flag=false,说明还没有生产好苹果,那么阻塞当前线程,然后释放锁
                        apple.wait();
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }
                //走到这说明flag=true,有苹果了
                apple.take();//消费苹果
                apple.flag = false;//设置为false,表示消费者消费完了
                apple.notify();//唤醒producer生产苹果
            }
        }
    }
}
```

```java
//主类
public class Main {
    public static void main(String[] args) {
        Apple apple = new Apple();
        Producer producer = new Producer(apple);
        Consumer consumer = new Consumer(apple);
        new Thread(producer).start();
        new Thread(consumer).start();
    }
}
```

```properties
生产第1个苹果
消费第1个苹果
生产第2个苹果
消费第2个苹果
```



## 二 线程池的使用

### 1 工具类--`Executors`

#### 1.1 简介

![1534408279514](并发编程笔记.assets/1534408279514.png)



> j.u.c包下的,创建线程池的类,
>
> `Executors`是顶层类,我们常用的是他的子类`ExecutorService` 和`ThreadPoolExecutor`



#### 1.2 创建线程的5种方法

**Executors.newSingleThreadExecutor()**

> 创建一个单线程的线程池。
>
> 这个线程池只有一个线程在工作，也就是相当于单线程串行执行所有任务。如果这个唯一的线程因为异常结束，那么会有一个新的线程来替代它。 此线程池保证所有任务的执行顺序按照任务的提交顺序执行。 

**Executors.newCachedThreadPool()**

> 创建一个可缓存的线程池。此线程池不会对线程池大小做限制，线程池大小完全依赖于操作系统（或者说JVM）能够创建的最大线程大小。 
>
> 如果线程池的大小超过了处理任务所需要的线程， 那么就会回收部分空闲（60秒不执行任务）的线程，当任务数增加时，此线程池又可以智能的添加新线程来处理任务。 

 **Executors.newFixedThreadPool(4)**

> 创建固定大小的线程池。
>
> 每次提交一个任务就创建一个线程，直到线程达到线程池的最大大小。 线程池的大小一旦达到最大值就会保持不变，如果某个线程因为执行异常而结束，那么线程池会补充一个新线程。 

**Executors.newSingleThreadScheduledExecutor()**

> 只有一个线程，用来调度执行将来的任务，

**Executors.newScheduledThreadPool(4)**

> 用来调度即将执行的任务的线程池
>
> ```java
> ScheduledExecutorService exec = Executors.newScheduledThreadPool(4); //创建调度线程池
> /*
> ScheduledExecutorService的特殊调度方法
> */
> //10s后运行线程,运行一次
> Future submit = exec.schedule(new MyCallable(), 10, TimeUnit.SECONDS);
> 
> //延迟一秒后,当前一个任务完成后,延迟3秒在运行下一个任务(周期性)
> exec.scheduleWithFixedDelay(()-> log.info("run..."),1,3, TimeUnit.SECONDS);
> 
> //延迟一秒后,每隔3s,固定执行任务。
> exec.scheduleAtFixedRate(() -> log.info("run..."), 1, 3, TimeUnit.SECONDS);
> ```

#### 1.3 线程池使用示例

```java
public static void main(String[] args) throws Exception {
    int cpuNums = Runtime.getRuntime().availableProcessors();//获取系统cpu的个数
    ExecutorService service = null;
    try {
        //当任务个数不确定的时候,不建议使用这种方式,会导致内存溢出(创建的队列大小是最大值)
        service = Executors.newFixedThreadPool(cpuNums);
        for (int i = 1; i <= 100; i++) {
            service.submit(new runable()); //提交任务
        }
    } catch (Exception e) {
        log.error("线程运行出错:{}", e);
    } finally {
        if (service != null) {
            service.shutdown();//当所有的任务完成后,才会关闭线程池
        }
    }

    //监控线程任务是否全部完成
    while (true) {
        if (service.isTerminated()) {
            //做一些善后的工作..,关闭数据库连接等
            break;
        }
        Thread.sleep(200);
    }
}
```



### 2 `ThreadPoolExecutor`

#### 2.1 示例

```java
public static void main(String[] args) {
    ExecutorService service = Executors.newFixedThreadPool(4);
}

//Executors
public static ExecutorService newFixedThreadPool(int nThreads) {
     //默认创建的LinkedBlockingQueue的空间是Integer.MAX_VALUE
     //任务个数不明确的时候,线上使用很危险,任务太多会导致内存溢出
		return new ThreadPoolExecutor(nThreads, nThreads, 0L, TimeUnit.MILLISECONDS,
                                      new LinkedBlockingQueue<Runnable>());
}
//ThreadPoolExecutor
public ThreadPoolExecutor(int corePoolSize,int maximumPoolSize,long keepAliveTime,
                          TimeUnit unit,BlockingQueue<Runnable> workQueue) {
    this(corePoolSize, 		//核心线程数
         maximumPoolSize,   //最大线程数
         keepAliveTime,     //线程空闲时间,超时回收(针对大于核心线程数,到最大线程数的这些线程)
         unit, 			   //时间单位
         workQueue,		   //缓存队列,当核心线程数都在忙的时候,就会把任务放入queue中
         Executors.defaultThreadFactory(), //线程工厂,用来创建线程
         new AbortPolicy()); //线程池对拒绝任务的处理策略(队列满了,线程用完了) 默认抛异常
}
```

#### 2.2 运行逻辑

1. 新任务来时,先用核心线程数`corePoolSize`的线程来处理

2. `corePoolSize`都在处理任务,就把新任务放队列中

3.  `CorePoolSize`都在运行,队列也满了,就创建新线程到`MaxPoolSize` 

4. 线程数量已经达到`MaxPoolsize`,队列也满了,那么就会执行拒绝策略 (默认是抛异常)

   ![1534408871899](并发编程笔记.assets/1534408871899.png)



#### 2.3 构造参数详解

| 参数                | 解释                                                         |
| ------------------- | ------------------------------------------------------------ |
| **corePoolSize**    | 线程池核心线程<br />默认情况下，在创建了线程池后，线程池中的线程数为0，当有任务来之后，就会创建一个线程去执行任务，当线程池中的线程数目达到corePoolSize后，就会把到达的任务放到缓存队列当中 <br />调用下面的方法,可以在线程初始化的时候,创建线程<br />prestartCoreThread()：初始化一个核心线程；<br />prestartAllCoreThreads()：初始化所有核心线程 |
| **maximumPoolSize** | 线程池最大线程数<br />这个参数也是一个非常重要的参数，它表示在线程池中最多能创建多少个线程,创建的线程数,超过了它,就会执行拒绝策略 |
| **keepAliveTime**   | 表示线程没有任务执行时最多保持多久时间会终止。<br />**默认情况下，只有当线程池中的线程数大于corePoolSize时，keepAliveTime才会起作用**，直到线程池中的线程数不大于corePoolSize。<br />但是如果调用了allowCoreThreadTimeOut(boolean)方法，在线程池中的线程数不大于corePoolSize时，keepAliveTime参数也会起作用，直到线程池中的线程数为0； |
| **unit**            | 时间单位                                                     |
| **workQueue**       | 阻塞队列，用来存储等待执行的任务 <br />当线程池中的线程数目达到corePoolSize后，就会把到达的任务放到缓存队列当中 |
| **threadFactory**   | 线程工厂，主要用来创建线程                                   |
| **handler**         | 表示当拒绝处理任务时的策略 <br />`ThreadPoolExecutor.AbortPolicy`:默认策略.,抛出异常<br />`ThreadPoolExecutor.DiscardPolicy`：也是丢弃任务，但是不抛出异常。<br />`ThreadPoolExecutor.DiscardOldestPolicy`：丢弃队列最前面的任务，然后重新尝试把当前线程任务加入队列（重复此过程）<br />`ThreadPoolExecutor.CallerRunsPolicy`：由调用线程处理该任务 |

> 任务队列选型:
>
> * **ArrayBlockingQueue** ：一个由数组结构组成的有界阻塞队列。
>   * FIFO原则
> * **LinkedBlockingQueue** ：一个由链表结构组成的有界阻塞队列。 
>   * FIFO原则
> * PriorityBlockingQueue ：一个支持优先级排序的无界阻塞队列。
>   * 队列没有最大限制,优先级高的线程先处理
> * SynchronousQueue： 一个不存储元素的阻塞队列。 
>   * 每个插入操作必须等到另一个线程调用移除操作,否则插入操作一直处于阻塞状态.
> * LinkedTransferQueue： 一个由链表结构组成的无界阻塞队列。 

#### 2.4 使用案例

```java
//1获取系统cpu数
int cpuNums = Runtime.getRuntime().availableProcessors();
ThreadPoolExecutor executor = null;
try {
    //2创建线程池,(注意:此时不会创建线程)
    //核心线程等于cpu个数,满了放队列 可以放100个,队列满了在创建线程到cpuNums*2 ,空闲线程5分钟销毁
    executor = new ThreadPoolExecutor(cpuNums,
                                      cpuNums*2,
                                      5,
                                      TimeUnit.MINUTES,
                                      new LinkedBlockingDeque<>(100));

    for(int i =0 ;i<100;i++){
        //3提交任务
        executor.execute(() -> {
            //我们提交的任务逻辑
        });
    }
} catch (Exception e) {
    e.printStackTrace();
} finally {
    if (executor != null) {
        executor.shutdown();//此时,不接收新任务当所有的任务完成后,才会关闭线程池
    }
}

//4监控线程任务是否全部完成
while (true) {
    if (executor != null && executor.isTerminated()) {
        log.info("======================任务全部完成======================");
        break;
    }
    try {
        Thread.sleep(200);
    } catch (InterruptedException e) {
        log.error("线程中断异常");
    }
}
```



### 3 常用方法

#### 3.1 提交任务 -`execute()`-`submit()`

* execute() 处理没有返回值的方法
* submit(): 处理有返回值的方法

#### 3.2 停止线程-`shutdown()`-`shutdownNow()`

**shutdown()**

* 当运行了shutdown()方法后,线城池不接收新的任务，但是会处理队列中的任务和正在运行中的任务,当处理完之后,会调用terminated()方法停止线程
* 线城池会从`running状态`---> `shutdown状态`

源码解析:

```java
public void shutdown() {
    final ReentrantLock mainLock = this.mainLock;
    mainLock.lock();
    try {
        checkShutdownAccess();
        advanceRunState(SHUTDOWN);
        interruptIdleWorkers();//中断空闲的线程实际调用了thread.interrupt()方法
        onShutdown(); // hook for ScheduledThreadPoolExecutor
    } finally {
        mainLock.unlock();
    }
    tryTerminate();//用一个循环来判断任务是否完成,完后后关闭线程
}
```

```java
 final void tryTerminate() {
        for (;;) {
            int c = ctl.get();
            if (isRunning(c) ||
                runStateAtLeast(c, TIDYING) ||
                (runStateOf(c) == SHUTDOWN && ! workQueue.isEmpty()))
                return;
            if (workerCountOf(c) != 0) { // Eligible to terminate
                interruptIdleWorkers(ONLY_ONE);
                return;
            }

            final ReentrantLock mainLock = this.mainLock;
            mainLock.lock();
            try {
                //变成TIDYING状态:没有执行任务的线程,队列为空
                //当线程池状态为TIDYING时,调用terminated方法
                if (ctl.compareAndSet(c, ctlOf(TIDYING, 0))) {
                    try {
                        terminated();
                    } finally {
                        ctl.set(ctlOf(TERMINATED, 0));
                        termination.signalAll();
                    }
                    return;
                }
            } finally {
                mainLock.unlock();
            }
            // else retry on failed CAS
        }
    }
```

```java
//是一个空方法,没有具体实现,当调用时,就表示,线程状态变为terminated
protected void terminated() { }
```



**shutdownNow()**

* 当运行了shutdownNow()不接收新的任务，抛弃队列中的任务，中断正在执行任务的线程(调用thread.interrupt();)

  * thread.interrupt():如果线程阻塞,抛出异常`InterruptedException`异常,否则只是设置线程的中断标记为true,线程任务还是会继续运行完成

  ```java
  public static void main(String[] args) {
      ThreadPoolExecutor executor =
          new ThreadPoolExecutor(4, 4, 1, TimeUnit.SECONDS, new LinkedBlockingQueue<>(10));
      for (int i = 0; i < 10; i++) {
          final int flag = i;
          executor.execute(()->{
              // set.add()目的是为了让线程运行时间久一点,方便观察
              HashSet<Integer> set = new HashSet<>();
              for (int j = 0; j < 1000000; j++) {
                  set.add(j);
              }
              log.info("flag:{},size,{}",flag,set.size());
          });
      }
      executor.shutdownNow();
      log.info("send shutdownNow()");
  }
  ```

  可以看出,调用了shutdownNow()后,队列中的剩余6个任务被抛弃了,正在运行的4个线程会运行完,因为只是调用了interrupt()方法.

  ```properties
  17:42:02.518 [main]  - send shutdownNow() 
  17:42:03.553 [pool-1-thread-2]  - flag:1,size,1000000
  17:42:03.562 [pool-1-thread-4]  - flag:3,size,1000000
  17:42:03.564 [pool-1-thread-3]  - flag:2,size,1000000
  17:42:03.564 [pool-1-thread-1]  - flag:0,size,1000000
  ```

  **源码解析**

  ```java
  public List<Runnable> shutdownNow() {
      List<Runnable> tasks;
      final ReentrantLock mainLock = this.mainLock;
      mainLock.lock();
      try {
          checkShutdownAccess();
          advanceRunState(STOP);//修改线程状态为stop
          interruptWorkers();//调用thread.interrupt()方法
          tasks = drainQueue();//把队列中任务清空,并返回给一个list
      } finally {
          mainLock.unlock();
      }
      tryTerminate();//尝试关闭线程池
      return tasks; //把队列中的任务返回
  }
  ```


#### 3.3 线程池的监控方法

| 方法名                  | 解释                                                         |
| ----------------------- | ------------------------------------------------------------ |
| getTaskCount()          | 线程池已执行和未执行的任务总数                               |
| getCompletedTaskCount() | 线程池运行过程中,已完成的任务数量                            |
| getLargestPoolSize()    | 线程池曾经创建过的最大线程数,通过这个数据可以知道线程池是否满过 |
| getPoolSize()           | 线程池的线程数量.如果线程池不销毁,核心线程不会销毁           |
| getActiveCount()        | 当前正在执行任务的线程数                                     |
| isShutdown()            | 线程池的状态只要不是running就返回true                        |
| isTerminated()          | 返回true,线程池就真的关闭了                                  |



### 4 线程池的5种状态

通过源码我们可以看到线程池一共有5种状态

```java
public class ThreadPoolExecutor extends AbstractExecutorService { 
	 private static final int COUNT_BITS = Integer.SIZE - 3;
    // runState is stored in the high-order bits
    private static final int RUNNING    = -1 << COUNT_BITS; // 10进制: -536870912
    private static final int SHUTDOWN   =  0 << COUNT_BITS; // 10进制: 0
    private static final int STOP       =  1 << COUNT_BITS; //536870912
    private static final int TIDYING    =  2 << COUNT_BITS; //10进制: 1073741824
    private static final int TERMINATED =  3 << COUNT_BITS;//10进制:  1610612736
}
```

下面详细分析这5种状态:

![1534475780366](并发编程笔记.assets/1534475780366.png)



* RUNNING：接收新的任务，并且处理队列中的任务。
* SHUTDOWN：不接收新的任务，但是会处理队列中的任务和正在运行中的任务。
* STOP：不接收新的任务，也不处理队列中的任务，中断正在执行任务的线程(调用thread.interrupt();)
  * 其实就相当于让整个线程池终止了
* TIDYING：所有任务都已经终止，没有正在执行任务的线程，队列也为空,将运行terminated()方法
* TERMINATED:terminated()方法执行完毕。

###  5 合理的配置线程池

* CPU密集型任务: N~cpu~ +1
* IO密集型任务: 2*N~cpu~
* 获取CPU的个数: `Runtime.getRuntime().availableProcessors()`

## 

## 三 锁的使用

### 1 `Lock`接口

```java
public interface Lock {

    void lock();
    void lockInterruptibly() throws InterruptedException;
    boolean tryLock();
    boolean tryLock(long time, TimeUnit unit) throws InterruptedException;
    void unlock();
    Condition newCondition();

}
```



### 2 ReentrantReadWriteLock 的问题

1 如果读取执行情况很多，写入很少的情况下，使用 ReentrantReadWriteLock 可能会使写入线程遭遇饥饿（Starvation）问题，也就是写入线程迟迟无法竞争到锁定而一直处于等待状态。 

 

### 4 StampedLock(since jdk1.8)

==不建议使用,不太了解原理==

#### 4.1 简介

如果读取执行情况很多，写入很少的情况下，使用 ReentrantReadWriteLock 可能会使写入线程遭遇饥饿（Starvation）问题，也就是写入线程迟迟无法竞争到锁定而一直处于等待状态。 

Java 8 引入了一个新的读写锁叫StampedLock. 不仅这个锁更快，而且它提供强大的乐观锁API，这意味着你能以一个较低的代价获得一个读锁, 在这段时间希望没有写操作发生，当这段时间完成后，你可以查询一下锁，看是否在刚才这段时间是否有写操作发生？然后你可以决定是否需要再试一次 或升级锁或放弃。

StampedLock控制锁有三种模式，一个StampedLock状态是由版本和模式两个部分组成，锁获取方法返回一个数字作为票据stamp，它用相应的锁状态表示并控制访问，数字0表示没有写锁被授权访问。==在读锁上分为悲观锁和乐观锁。==

* 写锁writeLock，是个排它锁或者叫独占锁(不能和其他锁共存)，同时只有一个线程可以获取该锁，当一个线程获取该锁后，其它请求的线程必须等待，当目前没有线程持有读锁或者写锁的时候才可以获取到该锁，请求该锁成功后会返回一个stamp票据变量用来表示该锁的版本，当释放该锁时候需要unlockWrite并传递参数stamp。

* 悲观读锁readLock，是个共享锁，在没有线程获取独占写锁的情况下，同时多个线程可以获取该锁，如果已经有线程持有写锁，其他线程请求获取该读锁会被阻塞。这里讲的悲观其实是参考数据库中的乐观悲观锁的，这里说的悲观是说在具体操作数据前悲观的认为其他线程可能要对自己操作的数据进行修改，所以需要先对数据加锁，这是在读少写多的情况下的一种考虑,请求该锁成功后会返回一个stamp票据变量用来表示该锁的版本，当释放该锁时候需要unlockRead并传递参数stamp。

* 乐观读锁tryOptimisticRead，是相对于悲观锁来说的，在操作数据前并没有通过CAS设置锁的状态，如果当前没有线程持有写锁，则简单的返回一个非0的stamp版本信息，获取该stamp后在具体操作数据前还需要调用validate验证下该stamp是否已经不可用，也就是看当调用tryOptimisticRead返回stamp后到到当前时间间是否有其他线程持有了写锁，如果是那么validate会返回0，否者就可以使用该stamp版本的锁对数据进行操作。由于tryOptimisticRead并没有使用CAS设置锁状态所以不需要显示的释放该锁。==该锁的一个特点是适用于读多写少的场景==，因为获取读锁只是使用与或操作进行检验，不涉及CAS操作，所以效率会高很多，但是同时由于没有使用真正的锁，在保证数据一致性上需要拷贝一份要操作的变量到方法栈，并且在操作数据时候可能其他写线程已经修改了数据，而我们操作的是方法栈里面的数据，也就是一个快照，所以最多返回的不是最新的数据，但是一致性还是得到保障的。

#### 4.2 源码中的示例

```java
public class Point {

    private final StampedLock lock = new StampedLock();
    private double x, y;

    //写入数据,和原来一样
    void move(double deltaX, double deltaY) {
        long stamp = lock.writeLock();
        try {
            x += deltaX;
            y += deltaY;
        } finally {
            lock.unlockWrite(stamp);
        }
    }

    //下面看看乐观读锁案例
    double distanceFromOrigin() { // A read-only method
        long stamp = lock.tryOptimisticRead(); //获得一个读乐观锁
        double currentX = x, currentY = y;  //将两个字段读入本地局部变量
        if (!lock.validate(stamp)) { //检查发出乐观读锁后同时是否有其他写锁发生？
            stamp = lock.readLock();  //如果没有，我们再次获得一个读悲观锁
            try {
                currentX = x; // 将两个字段读入本地局部变量
                currentY = y; // 将两个字段读入本地局部变量
            } finally {
                lock.unlockRead(stamp);
            }
        }
        return Math.sqrt(currentX * currentX + currentY * currentY);
    }

    //下面是悲观读锁案例
    void moveIfAtOrigin(double newX, double newY) { // upgrade
        // Could instead start with optimistic, not read mode
        long stamp = lock.readLock();
        try {
            while (x == 0.0 && y == 0.0) { //循环，检查当前状态是否符合
                long ws = lock.tryConvertToWriteLock(stamp); //将读锁转为写锁
                if (ws != 0L) { //这是确认转为写锁是否成功
                    stamp = ws; //如果成功 替换票据
                    x = newX; //进行状态改变
                    y = newY;  //进行状态改变
                    break;
                } else { //如果不能成功转换为写锁
                    lock.unlockRead(stamp);  //我们显式释放读锁
                    stamp = lock.writeLock();  //显式直接进行写锁 然后再通过循环再试
                }
            }
        } finally {
            lock.unlock(stamp); //释放读锁或写锁
        }
    }
}
```



#### 4.3 StampedLock的小bug

StampedLock在使用readLock()的时候，使用的是Unsafe.park()函数。park()在遇到线程中断时，会直接返回。这就导致阻塞在park()上面的线程被中断后，会再次进入循环，从而导致CPU的大量占用。以下是事例代码：

```java
public class StampedLockCPUDemo {
	static Thread[] holdCpuThreads = new Thread[7];//根据cpu个数定
	static final StampedLock lock = new StampedLock();
 
	public static void main(String[] args) throws InterruptedException {
		new Thread() {
			@Override
			public void run() {
				long readLong = lock.writeLock();
				LockSupport.parkNanos(600000000000L);
				lock.unlockWrite(readLong);
			}
		}.start();
		Thread.sleep(100);
		for (int i = 0; i < 7; ++i) {
			holdCpuThreads[i] = new Thread(new HoldCPUReadThread());
			holdCpuThreads[i].start();
		}
		Thread.sleep(10000);
		// 线程中断后，会占用CPU
		for (int i = 0; i < 7; ++i) {
			holdCpuThreads[i].interrupt();
		}
	}
 
	private static class HoldCPUReadThread implements Runnable {
		@Override
		public void run() {
			long lockr = lock.readLock();
			System.out.println(Thread.currentThread().getName() + "获得读锁");
			lock.unlockRead(lockr);
		}
	}
}
```

![1534861730294](并发编程笔记.assets/1534861730294.png)



```java
public long readLock() {
    long s = state, next;  // bypass acquireRead on common uncontended case
    return ((whead == wtail && (s & ABITS) < RFULL &&
             U.compareAndSwapLong(this, STATE, s, next = s + RUNIT)) ?
            next : acquireRead(false, 0L));
}
```



```java
private long acquireRead(boolean interruptible, long deadline) {
    ...
        for (int spins = -1;;) {
		...
            U.park(false, time);//这块会直接返回,然后程序一直卡死在for循环中
        ...
        }
       ...
}
```







1. [并发编程的博客](https://blog.csdn.net/jesonjoke/article/list/1 )
2. [java菜鸟编程](http://www.runoob.com/java/java-modifier-types.html)
   1. 里面关于protected和java9的需要看看
3. [Java开发之@PostConstruct和@PreDestroy注解](http://www.mamicode.com/info-detail-1794755.html)
   1. 没有计划好,放在什么位置


